# Model Name Resolution Guide

## Overview

Version 3.1.0 introduces a comprehensive model name resolution system for the BedrockModelCatalog that makes it easier to work with AWS Bedrock models by supporting user-friendly names, flexible matching, and backward compatibility with legacy names.

## Table of Contents

- [What Changed](#what-changed)
- [Supported Name Formats](#supported-name-formats)
- [Name Resolution Examples](#name-resolution-examples)
- [Migration Scenarios](#migration-scenarios)
- [New Capabilities](#new-capabilities)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)
- [Legacy Name Mappings](#legacy-name-mappings)

## What Changed?

### Before v3.1.0

- Had to use exact API names like `"Claude Haiku 4 5 20251001"`
- Case-sensitive, spacing-sensitive name matching
- No support for friendly aliases
- Integration tests failed due to name mismatches
- Difficult to remember exact model names

### After v3.1.0

- Use friendly names like `"Claude 3 Haiku"`, `"Claude Haiku 4.5"`
- Case-insensitive, flexible matching (spacing, punctuation)
- Automatic alias generation for all models
- Full backward compatibility with UnifiedModelManager names
- Helpful error messages with suggestions
- Easy-to-remember model names

## Supported Name Formats

The catalog accepts multiple name formats for the same model:

### API Names (Exact)

These are the exact names returned by AWS Bedrock APIs:

```python
"Claude Haiku 4 5 20251001"  # API model name
"anthropic.claude-3-haiku-20240307-v1:0"  # Full model ID
```

### Friendly Aliases (Generated)

User-friendly, memorable names automatically generated by the system:

```python
"Claude 3 Haiku"      # Simple, memorable name
"Claude Haiku 3"      # Alternative word order
"Claude 3.5 Sonnet"   # Version with decimal notation
"Claude Sonnet 3.5"   # Alternative word order
"claude-3-haiku"      # Lowercase with hyphens
"Claude3Haiku"        # No spaces
```

### Legacy Names (Backward Compatible)

All UnifiedModelManager names are automatically supported:

```python
"Claude 3 Haiku"           # Legacy name
"Titan Text G1 - Lite"     # Legacy name
"Llama 3 8B Instruct"      # Legacy name
```

### Flexible Matching

The system handles variations automatically:

- **Case Insensitive**: `"claude 3 haiku"` = `"Claude 3 Haiku"` = `"CLAUDE 3 HAIKU"`
- **Spacing Variations**: `"Claude3Haiku"` = `"Claude 3 Haiku"` = `"Claude  3  Haiku"`
- **Punctuation Variations**: `"Claude-3-Haiku"` = `"Claude_3_Haiku"` = `"Claude.3.Haiku"`
- **Version Formats**: `"4.5"` = `"4 5"` = `"45"`
- **Word Order**: `"Claude 3 Haiku"` = `"Claude Haiku 3"`
- **Provider Prefixes**: `"Anthropic Claude 3 Haiku"` = `"Claude 3 Haiku"`

## Name Resolution Examples

### Basic Usage

```python
from bestehorn_llmmanager.bedrock.catalog import BedrockModelCatalog

catalog = BedrockModelCatalog()

# All of these resolve to the same model:
model_info = catalog.get_model_info("Claude 3 Haiku", "us-east-1")
model_info = catalog.get_model_info("Claude Haiku 3", "us-east-1")
model_info = catalog.get_model_info("claude-3-haiku", "us-east-1")
model_info = catalog.get_model_info("CLAUDE 3 HAIKU", "us-east-1")
model_info = catalog.get_model_info("Claude3Haiku", "us-east-1")
```

### Version Number Flexibility

```python
# All of these resolve to the same model:
model_info = catalog.get_model_info("Claude 3.5 Sonnet", "us-east-1")
model_info = catalog.get_model_info("Claude Sonnet 3.5", "us-east-1")
model_info = catalog.get_model_info("Claude 3 5 Sonnet", "us-east-1")
model_info = catalog.get_model_info("Claude Sonnet 35", "us-east-1")
```

### Provider Prefix Handling

```python
# These all resolve to the same model:
model_info = catalog.get_model_info("Claude 3 Haiku", "us-east-1")
model_info = catalog.get_model_info("Anthropic Claude 3 Haiku", "us-east-1")
model_info = catalog.get_model_info("APAC Claude 3 Haiku", "us-east-1")
model_info = catalog.get_model_info("EU Anthropic Claude 3 Haiku", "us-east-1")
```

### Legacy UnifiedModelManager Names

```python
# All legacy names continue to work:
model_info = catalog.get_model_info("Claude 3 Haiku", "us-east-1")
model_info = catalog.get_model_info("Titan Text G1 - Lite", "us-east-1")
model_info = catalog.get_model_info("Llama 3 8B Instruct", "us-east-1")
```

## Migration Scenarios

### Scenario 1: Using LLMManager with Model Names

**No changes required!** All existing code continues to work:

```python
from bestehorn_llmmanager import LLMManager, create_user_message

# This code works in both old and new versions
manager = LLMManager(
    models=["Claude 3 Haiku", "Claude 3 Sonnet"],
    regions=["us-east-1", "us-west-2"]
)

message = create_user_message().add_text("Hello!").build()
response = manager.converse(messages=[message])
```

### Scenario 2: Using BedrockModelCatalog Directly

**No changes required!** The API remains the same:

```python
from bestehorn_llmmanager.bedrock.catalog import BedrockModelCatalog

catalog = BedrockModelCatalog()

# This code works in both old and new versions
model_info = catalog.get_model_info("Claude 3 Haiku", "us-east-1")
is_available = catalog.is_model_available("Claude 3 Sonnet", "us-west-2")
```

### Scenario 3: Integration Tests

**No changes required!** Tests using friendly names now work automatically:

```python
import pytest
from bestehorn_llmmanager import LLMManager, create_user_message

def test_claude_haiku():
    """Test using Claude 3 Haiku - works automatically now!"""
    manager = LLMManager(
        models=["Claude 3 Haiku"],  # Automatically resolved
        regions=["us-east-1"]
    )
    
    message = create_user_message().add_text("Hello").build()
    response = manager.converse(messages=[message])
    
    assert response.success
    assert response.get_content()
```

### Scenario 4: Handling Name Resolution Errors

**New capability!** Better error messages with suggestions:

```python
from bestehorn_llmmanager import LLMManager
from bestehorn_llmmanager.bedrock.exceptions import ConfigurationError

try:
    manager = LLMManager(
        models=["Claude 3 Hiku"],  # Typo in model name
        regions=["us-east-1"]
    )
except ConfigurationError as e:
    # NEW: Error message includes helpful suggestions
    print(e)
    # "Model 'Claude 3 Hiku' not found. Did you mean: Claude 3 Haiku, 
    #  Claude 3.5 Haiku, Claude 3 Sonnet?"
    
    # You can now fix the typo and retry
    manager = LLMManager(
        models=["Claude 3 Haiku"],  # Corrected
        regions=["us-east-1"]
    )
```

## New Capabilities

### 1. Flexible Name Formats

You can now use multiple name formats interchangeably:

```python
from bestehorn_llmmanager import LLMManager

# All of these work and refer to the same model:
manager1 = LLMManager(models=["Claude 3 Haiku"], regions=["us-east-1"])
manager2 = LLMManager(models=["Claude Haiku 3"], regions=["us-east-1"])
manager3 = LLMManager(models=["claude-3-haiku"], regions=["us-east-1"])
manager4 = LLMManager(models=["CLAUDE 3 HAIKU"], regions=["us-east-1"])
manager5 = LLMManager(models=["Claude3Haiku"], regions=["us-east-1"])
```

### 2. Version Number Flexibility

Version numbers can be specified in multiple formats:

```python
# All of these resolve to the same model:
manager1 = LLMManager(models=["Claude 3.5 Sonnet"], regions=["us-east-1"])
manager2 = LLMManager(models=["Claude 3 5 Sonnet"], regions=["us-east-1"])
manager3 = LLMManager(models=["Claude Sonnet 3.5"], regions=["us-east-1"])
manager4 = LLMManager(models=["Claude Sonnet 35"], regions=["us-east-1"])
```

### 3. Provider Prefix Handling

Provider prefixes are automatically normalized:

```python
# These all resolve to the same model:
manager1 = LLMManager(models=["Claude 3 Haiku"], regions=["us-east-1"])
manager2 = LLMManager(models=["Anthropic Claude 3 Haiku"], regions=["us-east-1"])
manager3 = LLMManager(models=["APAC Claude 3 Haiku"], regions=["us-east-1"])
```

### 4. Legacy Name Support

All UnifiedModelManager names continue to work:

```python
# Legacy names from UnifiedModelManager still work
manager = LLMManager(
    models=[
        "Claude 3 Haiku",           # Legacy name
        "Titan Text G1 - Lite",     # Legacy name
        "Llama 3 8B Instruct"       # Legacy name
    ],
    regions=["us-east-1"]
)
```

### 5. Helpful Error Messages

When a model name cannot be resolved, you get suggestions:

```python
from bestehorn_llmmanager.bedrock.exceptions import ConfigurationError

try:
    catalog.get_model_info("Claude 3 Hiku", "us-east-1")  # Typo
except ConfigurationError as e:
    print(e)
    # "Model 'Claude 3 Hiku' not found in region 'us-east-1'. 
    #  Did you mean: Claude 3 Haiku, Claude 3.5 Haiku, Claude 3 Sonnet?"
```

## Best Practices

### 1. Use Friendly Names

Prefer friendly, memorable names over API names:

```python
# GOOD: Easy to read and remember
manager = LLMManager(
    models=["Claude 3 Haiku", "Claude 3.5 Sonnet"],
    regions=["us-east-1"]
)

# AVOID: Hard to read and remember
manager = LLMManager(
    models=["anthropic.claude-3-haiku-20240307-v1:0"],
    regions=["us-east-1"]
)
```

### 2. Handle Configuration Errors

Always catch and handle configuration errors:

```python
from bestehorn_llmmanager import LLMManager
from bestehorn_llmmanager.bedrock.exceptions import ConfigurationError
import logging

logger = logging.getLogger(__name__)

try:
    manager = LLMManager(
        models=["My Model Name"],
        regions=["us-east-1"]
    )
except ConfigurationError as e:
    # Log the error with suggestions
    logger.error(f"Model configuration error: {e}")
    # Use a fallback model
    manager = LLMManager(
        models=["Claude 3 Haiku"],  # Fallback
        regions=["us-east-1"]
    )
```

### 3. Validate Model Names Early

Validate model names during initialization:

```python
from bestehorn_llmmanager.bedrock.catalog import BedrockModelCatalog

def validate_model_names(model_names, region):
    """Validate model names before creating LLMManager."""
    catalog = BedrockModelCatalog()
    
    invalid_models = []
    for model_name in model_names:
        if not catalog.is_model_available(model_name, region):
            invalid_models.append(model_name)
    
    if invalid_models:
        raise ValueError(f"Invalid models: {invalid_models}")
    
    return True

# Validate before creating manager
model_names = ["Claude 3 Haiku", "Claude 3 Sonnet"]
validate_model_names(model_names, "us-east-1")

manager = LLMManager(models=model_names, regions=["us-east-1"])
```

### 4. Use List Models for Discovery

Discover available models programmatically:

```python
from bestehorn_llmmanager.bedrock.catalog import BedrockModelCatalog

catalog = BedrockModelCatalog()

# List all models in a region
models = catalog.list_models(region="us-east-1")

# Filter by provider
anthropic_models = catalog.list_models(
    region="us-east-1",
    provider="Anthropic"
)

# Print available model names
print("Available Anthropic models:")
for model in anthropic_models:
    print(f"  - {model.model_name}")
```

### 5. Use Consistent Naming

Choose a naming convention and stick to it:

```python
# GOOD: Consistent naming
manager = LLMManager(
    models=[
        "Claude 3 Haiku",
        "Claude 3 Sonnet",
        "Claude 3 Opus"
    ],
    regions=["us-east-1"]
)

# AVOID: Inconsistent naming
manager = LLMManager(
    models=[
        "Claude 3 Haiku",
        "claude-3-sonnet",
        "CLAUDE 3 OPUS"
    ],
    regions=["us-east-1"]
)
```

## Troubleshooting

### Problem: "Model not found" error

**Symptom:**
```
ConfigurationError: Model 'My Model' not found in region 'us-east-1'
```

**Solution:**
1. Check the error message for suggestions
2. List available models in the region
3. Use a suggested model name

```python
from bestehorn_llmmanager.bedrock.catalog import BedrockModelCatalog

catalog = BedrockModelCatalog()

# List available models
models = catalog.list_models(region="us-east-1")
print("Available models:")
for model in models:
    print(f"  - {model.model_name}")
```

### Problem: Ambiguous model name

**Symptom:**
```
ConfigurationError: Ambiguous model name 'Claude'. Could refer to: 
Claude 3 Haiku, Claude 3 Sonnet, Claude 3 Opus, Claude 3.5 Sonnet
```

**Solution:**
Use a more specific model name:

```python
# TOO GENERIC
manager = LLMManager(models=["Claude"], regions=["us-east-1"])

# SPECIFIC
manager = LLMManager(models=["Claude 3 Haiku"], regions=["us-east-1"])
```

### Problem: Legacy model no longer available

**Symptom:**
```
ConfigurationError: Model 'Old Model Name' is no longer available. 
Similar models: New Model Name 1, New Model Name 2
```

**Solution:**
Update to a current model based on suggestions:

```python
# OLD (deprecated)
manager = LLMManager(models=["Old Model Name"], regions=["us-east-1"])

# NEW (current)
manager = LLMManager(models=["New Model Name 1"], regions=["us-east-1"])
```

### Problem: Typo in model name

**Symptom:**
```
ConfigurationError: Model 'Claude 3 Hiku' not found. 
Did you mean: Claude 3 Haiku, Claude 3.5 Haiku?
```

**Solution:**
Fix the typo based on suggestions:

```python
# TYPO
manager = LLMManager(models=["Claude 3 Hiku"], regions=["us-east-1"])

# CORRECTED
manager = LLMManager(models=["Claude 3 Haiku"], regions=["us-east-1"])
```

### Problem: Case sensitivity issues

**Symptom:**
Model name works in one format but not another.

**Solution:**
The system is case-insensitive, so this shouldn't be an issue. If you encounter problems:

```python
# All of these should work:
manager = LLMManager(models=["Claude 3 Haiku"], regions=["us-east-1"])
manager = LLMManager(models=["claude 3 haiku"], regions=["us-east-1"])
manager = LLMManager(models=["CLAUDE 3 HAIKU"], regions=["us-east-1"])

# If one doesn't work, check for typos or extra characters
```

## Legacy Name Mappings

The following legacy UnifiedModelManager names are automatically mapped to their BedrockModelCatalog equivalents:

### Claude Models

| Legacy Name | Resolves To |
|------------|-------------|
| Claude 3 Haiku | anthropic.claude-3-haiku-20240307-v1:0 |
| Claude 3 Sonnet | anthropic.claude-3-sonnet-20240229-v1:0 |
| Claude 3 Opus | anthropic.claude-3-opus-20240229-v1:0 |
| Claude 3.5 Sonnet | anthropic.claude-3-5-sonnet-20240620-v1:0 |
| Claude 3.5 Haiku | anthropic.claude-3-5-haiku-20241022-v1:0 |

### Amazon Models

| Legacy Name | Resolves To |
|------------|-------------|
| Titan Text G1 - Lite | amazon.titan-tg1-large |
| Titan Text G1 - Express | amazon.titan-text-express-v1 |
| Nova Micro | amazon.nova-micro-v1:0 |
| Nova Lite | amazon.nova-lite-v1:0 |
| Nova Pro | amazon.nova-pro-v1:0 |

### Meta Models

| Legacy Name | Resolves To |
|------------|-------------|
| Llama 3 8B Instruct | meta.llama3-8b-instruct-v1:0 |
| Llama 3 70B Instruct | meta.llama3-70b-instruct-v1:0 |
| Llama 3.1 8B Instruct | meta.llama3-1-8b-instruct-v1:0 |
| Llama 3.1 70B Instruct | meta.llama3-1-70b-instruct-v1:0 |
| Llama 3.2 1B Instruct | meta.llama3-2-1b-instruct-v1:0 |
| Llama 3.2 3B Instruct | meta.llama3-2-3b-instruct-v1:0 |

### Other Providers

| Legacy Name | Resolves To |
|------------|-------------|
| Mistral 7B Instruct | mistral.mistral-7b-instruct-v0:2 |
| Mixtral 8x7B Instruct | mistral.mixtral-8x7b-instruct-v0:1 |
| Command R | cohere.command-r-v1:0 |
| Command R+ | cohere.command-r-plus-v1:0 |

**Note:** This is not an exhaustive list. The system automatically handles many more legacy names. If you encounter a legacy name that doesn't resolve, check the error message for suggestions.

## Testing Your Migration

After migrating, verify your code works correctly:

```python
import pytest
from bestehorn_llmmanager import LLMManager, create_user_message

def test_model_name_resolution():
    """Test that model names resolve correctly."""
    # Test with friendly name
    manager = LLMManager(
        models=["Claude 3 Haiku"],
        regions=["us-east-1"]
    )
    
    message = create_user_message().add_text("Hello").build()
    response = manager.converse(messages=[message])
    
    assert response.success
    assert response.model_used  # Verify model was used
    assert response.get_content()  # Verify response content

def test_multiple_name_formats():
    """Test that different name formats work."""
    name_formats = [
        "Claude 3 Haiku",
        "Claude Haiku 3",
        "claude-3-haiku",
        "CLAUDE 3 HAIKU",
        "Claude3Haiku"
    ]
    
    for name in name_formats:
        manager = LLMManager(models=[name], regions=["us-east-1"])
        message = create_user_message().add_text("Test").build()
        response = manager.converse(messages=[message])
        assert response.success, f"Failed with name format: {name}"

def test_error_handling():
    """Test that invalid names produce helpful errors."""
    from bestehorn_llmmanager.bedrock.exceptions import ConfigurationError
    
    with pytest.raises(ConfigurationError) as exc_info:
        manager = LLMManager(
            models=["Invalid Model Name"],
            regions=["us-east-1"]
        )
    
    # Verify error message includes suggestions
    error_message = str(exc_info.value)
    assert "not found" in error_message.lower()

def test_legacy_names():
    """Test that legacy UnifiedModelManager names work."""
    legacy_names = [
        "Claude 3 Haiku",
        "Claude 3 Sonnet",
        "Titan Text G1 - Lite"
    ]
    
    for name in legacy_names:
        manager = LLMManager(models=[name], regions=["us-east-1"])
        message = create_user_message().add_text("Test").build()
        response = manager.converse(messages=[message])
        assert response.success, f"Failed with legacy name: {name}"
```

## Summary

The model name resolution system in v3.1.0 provides:

1. **Zero Migration Effort**: Existing code continues to work without changes
2. **Better Usability**: Use friendly, memorable model names
3. **Flexibility**: Multiple name formats supported (case, spacing, punctuation)
4. **Backward Compatibility**: All legacy UnifiedModelManager names work
5. **Better Errors**: Helpful suggestions when names don't resolve
6. **Future-Proof**: Automatic alias generation for new models

**Key Benefits:**

- No code changes required to benefit from improvements
- Existing code automatically uses new name resolution system
- Better developer experience with memorable names
- Reduced errors with flexible matching
- Easier debugging with helpful error messages

**Getting Started:**

1. Update to version 3.1.0 or later
2. Continue using your existing model names (they still work!)
3. Optionally switch to friendlier names for better readability
4. Enjoy automatic name resolution and better error messages

No migration work is required - your existing code will automatically benefit from the new name resolution system!
