The test coverage for the following modules/files listed in <coverage></coverage> tags in the following is below the 80% threshold according to the coverage report obtained through test/run_tests.py :
<coverage>

</coverage>

Develop a strategy to improve the text coverage for those files in "src" that have a particularly low coverage. Add tests that improve the coverage for these files. Generally, we have a goal to get 80% coverage through the unit tests for this project.

While implementing these test cases, adhere to the coding standards provided in <standard></standard> tags:
<standard>
The produced code must adhere to software development best practices and be easily extensible/modifiable. Also the code must be readable. The code is for production use and not just a small experiment. This will serve as a foundation for further functionality and therefore the code has to be maintainable. Typization/Typing must be adhered in all cases and strictly.

When designing functionality, highest priority should be put to modularization: When a function or class has parts that can be seaprated, then these should be always separated to function as independent pieces. For instance, if a function f() does two steps s1 and and s2, then f() should be written by defining two sub-function that implement s1 and s2. In general, functions should always strive to be simple and breaking them into modular, parametrizable pieces is key for maintainability of code. Similarly, class design should use inheritance wherever applicable to allow for modularity in the code / design. 

Before implementing new classes, modules or functions, always review the functions already available and how these functions could be used for implementing additional functionality or whatever else is requested. If functions need changes to be usable, provide this as an option and review these changes with regards to breaking existing functionality.  Breaking existing functionality should always be avoided.

When functions indicate an error / malfunction, they must throw an exception. Indicating errors by returning empty lists, zero values or similar return values is not allowed. If the error or malfunction is expected, functions should return None to allow calling functions to handle the error by checking for None. More specifically, all custom exception classes must use details = None as the default when no specific detail parameters are provided, and only create a details dictionary when actual meaningful detail values are available (not None or empty). This ensures consistent behavior across the entire exception hierarchy and provides clear API semantics where None explicitly indicates "no details available" rather than an ambiguous empty dictionary.

Names of fields in JSON should generally accessed through str constants instead of explicitly writing the str into the code (str literals).  For instance, if a JSON object my_json_obj contains a field "content", then the code should not use my_json_obj["content"] but instead define a constant FIELD_CONTENT="content" and then use that constant for accessing the variable with my_json_obj[FIELD_CONTENT].
Use object oriented design principles to divide functions and provide useful abstractions to avoid code duplication. Use abstractions and interfaces where possible. Avoid having one large, unmanageable file with hundreds or thousands of lines of code. Classes should be in a single file with a corresponding name. Abstractions and inheritance should also be visible from the class name / file name.

Provide logging where necessary, but do not use excessive logging for default/successful cases. Use the logging library for generating logging output. 
To improve readability of the code, function calls should - wherever possible - use named parameters at the function call. For instance, if a function f() takes two parameters a and b of type int and str respectively, then the call to the function should be f(a=5, b="abc") instead of f(5,"abc"). This makes code easier to read as is immediately conveys - assuming parameters have been given proper names when writing the function - which parameter gets which value. 

The project structure is organized in such a way that the "src" folder contains all production code. This directory and any subdirectory must not contain any other code other than the code used for the production code. Temporary files or intermediate code snippets, files or classes do not belong into the "src" folder. If temporary code or other files needs to be created, the "workspace" directory is the place for these. Once an implementation task is done, this folder should be cleaned up and deleting files form this should must not have any effect on the solution. The "test" folder only has code for Python unit testing (Pytest), the "notebooks" directory has Jupyther notebooks for manual testing & demos. The directories "docs", "images" and "videos" contain documents/documentation, images and videos respectively. Use the structure as described above while implementing, most importantly, do not pollute the "src" directory with temporary code files. 

The project also has a coding strategy: the directory "test" mirrors the directory "src", i.e., for every file in "src", there is a corresponding file with the unit tests for that specific file in src and the complete directory structure in test mirrors src. When functions, classes or files are added to the src tree, corresponding tests must be introduced to the corresponding unit test file. When functions, classes or files are modified, the corresponding files in the test must be adapted to provide adequate testing for the new modified functionality. In general, the tests in "test" must always be in sync with the code in "src" and test configuration files must be adapted if modified functionaluty requires this. As a last step to any code submission, the tests must be run. If any tests fail, subsequented changes to the new code must be introduced to ensure that the new code is properly tested and works. Editing must continue until this state is reached. If changes require the removal of previously existing tests, such removal must be explicitly flagged to the user as this is a critical change.
 
</standard>

Do not make changes to files in the "src" directory or any of its subdirectories. Focus only on writing test cases to improve test coverage. For this task, look at each of the files that are below the aforementioned threshold and identify the parts of the code that are currently not covered. Develop for the uncovered parts of the file a proper set of test cases and add them to the appropriate file. Repeat this process for every file that has insufficient test coverage.

 